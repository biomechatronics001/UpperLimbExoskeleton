//for right knee exo, positive current assist extension, and torque sensor measures positive torque
#include "Insole_mod.h"
#include "Motor_Control_Gyems.h"
#include <SPI.h>
#include "ads1292r.h"
#include "Torque_Control.h"
#include "WL_IMU.h"
#include <Arduino.h>

double weight=80;       // [kg] weight of the subject
int Motor_ID1 = 4;      // Motor Can Bus ID, left leg, loadcell: port 1
int Motor_ID2 = 2;      // Motor Can Bus ID, right leg, loadcell: port 2
int CAN_ID = 0;         // CAN port from Teensy
int Stop_button = 0;    // Stop function
int assist_mode = 1;
String mode = "start";

Motor_Control_Gyems m1(Motor_ID1, CAN_ID);  //Create motor object see Motor_Control_Gyems.h
Motor_Control_Gyems m2(Motor_ID2, CAN_ID);  //Create motor object see Motor_Control_Gyems.h
ads1292r torque_sensor1;                //Create torque sensor object see ads1292r.h
Torque_Control Tor_control;             //Creare torque control object see Torque_control.h
IMU imu;                                //Create IMU object see WL_IMU.h
Insole insole;                          // Create insole object

double Pgain = 7.5;                 //P gain of torque control
double Igain = 0.7;                 //I gain of torque control
double Dgain = 0;                   //D gain of torque control
double MaxPIDout = 10;              //Max torque control PID output (Unit Current A, inner loop is current controller)

double Fsample = 500;                   // [Hz] teensy controller sample rate (Maximum frequency: 1000 Hz due to Can Bus)
double Fsample_ble = 100;               // [Hz] Bluetooth sending data frequency
double Fsample_insole = 200;            // [Hz] insole reading data frequency
unsigned long current_time = 0;         
unsigned long previous_time = 0;        // used to control the controller sample rate.
unsigned long previous_time_ble = 0;    // used to control the Bluetooth communication frequency
unsigned long previous_time_insole = 0; // used to control the insole reading data frequency
unsigned long Tinterval_microsecond = (unsigned long)(1000000/Fsample);               // used to control the teensy controller frequency
unsigned long Tinterval_ble_microsecond = (unsigned long)(1000000/Fsample_ble);       // used to control the Bluetooth communication frequency
unsigned long Tinterval_insole_microsecond = (unsigned long)(1000000/Fsample_insole); // used to control the insole reading data frequency
//double Tsample = 1 / Fsample;           // sample period (second)

double Cur_command_L = 0;
double Cur_command_R = 0;
int current_limitation=10;  //(unit Amp)//double Tor_command_L = 0;
//double Tor_command_R = 0;
//double Pos_command_L = 0;
//double Pos_command_R = 0;
//double milli_time_current_double = 0;

//***Data sent via bluetooth
char datalength_ble =32;           // Bluetooth Data Length
char data_ble[60] = {0};            // Data array for bluetooth data sending:  Teensy->RS232->Adafruit Feather nRF52840 Express(peripheral)->bluetooth->Adafruit Feather nRF52840 Express(central)->usb->computer
char data_rs232_rx[60] = {0};       // Data array for bluetooth data receive:  computer->USB->Adafruit Feather nRF52840 Express(central)->bluetooth->Adafruit Feather nRF52840 Express(peripheral)->RS232->Teensy
int LK_ble = 0;                     //left knee angel
int RK_ble = 0;                     //right knee angle
int current_command_L_ble = 0;      //current reference(A) for inner loop current control
int current_command_R_ble = 0;      
int torque_command_L_ble = 0;       //torque reference(N-m) generated by delay output feedback control
int torque_command_R_ble = 0;       
int torque_L_ble = 0;               //actual torque(N-m)(measured by torque sensor)
int torque_R_ble = 0;

//int percentage_ble = 0;  //gait percentage(%)
//int torque_commandGP_ble = 0;     //torque reference(N-m) generated by gait percentage VS torque reference table
//int current_ble = 0;              //actual current (A)

//***********High Level Communication*********//
int LK_highlevel = 0;
int RK_highlevel = 0;

int TK_highlevel = 0;
int LT_highlevel = 0;
int RT_highlevel = 0;
int LS_highlevel = 0;
int RS_highlevel = 0;

// double LK_highlevel = 0;
// double RK_highlevel = 0;

// double TK_highlevel = 0;
// double LT_highlevel = 0;
// double RT_highlevel = 0;
// double LS_highlevel = 0;
// double RS_highlevel = 0;

int Left_Knee_Torque = 0;
int Right_Knee_Torque = 0; 
char data_serial_highlevel[101]={0};
char data_highlevel_rx[7]={0};//data high level communication
char Highlevel_Data_Length_Send=101;
double Left_Knee_Torque_Commend;
double Right_Knee_Torque_Commend;

void setup() {
  // put your setup code here, to run once:
  delay(1000);
  Serial.begin(115200);       //used for communication with computer.
  Serial4.begin(115200);      //used to communication with bluetooth peripheral. Teensy->RS232->Adafruit Feather nRF52840 Express(peripheral)
  torque_sensor1.Torque_sensor_initial();     //initial the torque sensor see ads1292r.cpp.
  torque_sensor1.Torque_sensor_gain(0.0003446 * 0.625 / 0.75, 0.0003446 * 0.7353 / 0.75);     //set the calibration gain for torque sensor. Torque= gain* ADCvalue+offset.see ads1292r.cpp.
  torque_sensor1.Torque_sensor_offset_calibration();      //Auto offset the torque sensor to zero. see ads1292r.cpp.
  imu.Gain_E = 1;            //Extension gain for delay output feedback control
  imu.Gain_F = 1;            //Flexion gain for delay output feedback control
  imu.delaypoint = 0;        //realative to delay time (delaypoint*sampletime=delaytime) for delay output feedback control
  m1.init_motor_CAN();           // Strat the CAN bus communication & Motor Control
  m2.init_motor_CAN();           // Strat the CAN bus communication & Motor Control
  IMUCurrentControlSetup();  //initialize current control and IMU control. this is use for direct current control without torque PID loop (torque reference/torque constant= current reference -> current PID loop)
  //TorqueControlSetup();    //initialize torque control (if you want to use torque sensor as a feedback you also need to use this function)
  //CurrentControlSetup();
  //PositionControlSetup(); 
  insole.INIT();
}

void loop() {
  IMUCurrentControl();         //if you want to try torque control, please uncommment IMUCurrentControl(); and use this function.
  //TorqueControlExample();    //if you want to try torque control, please uncommment TorqueControlExample(); and use this function.
  //CurrentControlExample();   //if you want to try current control, please uncommment CurrentControlExample(); and use this function.
  //PositionControlExample();  //if you want to try position control, please uncommment PositionControlExample(); and use this function.
}

void IMUCurrentControlSetup()
{
  imu.INIT();    //Initialize IMU;
  delay(1000);
  imu.INIT_MEAN();
  current_time = micros();
  previous_time = current_time;
  previous_time_ble = current_time;
  previous_time_insole = current_time;
}

void IMUCurrentControl()
{
  ////******IMU+Current Control Example Torque Constant 0.6 Nm/A**********////////
  imu.READ();   //Check if IMU data available and read it. the sample rate is 200 hz
  //plot_imu_data();
  torque_sensor1.Torque_sensor_read(); //Check if torque sensor1 is available
  //plot_torque_sensor_data();

  current_time = micros();    //query current time (microsencond)

  //********* use to control the insole reading data frequency **********//
  if(current_time - previous_time_insole > Tinterval_insole_microsecond)
  {
    insole.READ();
    previous_time_insole = current_time;
    //plot_insole_data();
  }
  
  //********* use to control the teensy controller frequency **********//
  if (current_time - previous_time > Tinterval_microsecond) // check if the time period of control loop is already larger than Sample period of control loop (Tinterval_microsecond)
  {
    if (Stop_button) //stop
    {
      Cur_command_L=0;
      Cur_command_R=0;
    }
    else
    {
    //   Compute_Cur_Commands();
    }
    // Cur_limitation();
    Cur_command_L = 0.0;
    Cur_command_R = 0.0;
    m1.send_current_command(Cur_command_L);
    m2.send_current_command(Cur_command_R);    
    //you can plot the variable in Serial plotter to see the data below is some example
    //Plot IMU data
       Serial.print(imu.LTx); //plot left thigh angle (deg)
       Serial.print("  ");
       Serial.print(imu.RTx); //plot righ thigh angle (deg)
       Serial.print("  ");
       Serial.print(imu.LSx); //plot left shank angle (deg)
       Serial.print("  ");
       Serial.println(imu.RSx); //plot left shank angle (deg)
    //    Serial.print("  ");
      //  Serial.print(imu.LKx); //plot left knee angle (deg)
      //  Serial.print("  ");
      //  Serial.println(imu.RKx); //plot right knee angle (deg)
    //    Serial.print("  ");
    //    Serial.print(imu.LRK[imu.currentpoint]); //plot current angle difference (left knee angle - righ knee angle)
    //    Serial.print("  ");
    //Plot controller data
    //    Serial.println(m1.cur_A * 10); //plot actual current
    //    Serial.print("  ");
//       Serial.print(imu.LKx); //plot current_command(A)*10
//       Serial.print("  ");
//       Serial.print(imu.RKx); //plot current_command(A)*10
//       Serial.print("  ");
//       Serial.print(imu.DOTC[0]); //plot right leg torque command *10 of delay output feedback control
//       Serial.print("  ");
//       Serial.println(imu.DOTC[1]); //plot right leg torque command *10 of delay output feedback control
    //    Serial.print("  ");
    //    Serial.print(imu.percentage_r/10); //plot right leg gait percentage/10 (0% is heel strike)
    //    Serial.print("  ");
    //    Serial.print(imu.DOTC[1] * 10); //plot right leg torque command *10 of delay output feedback control                          
    previous_time = current_time; //reset previous control loop time
    //plot_controller_data();
  }
    
  //********* use to control the Bluetooth communication frequency **********//
  if (current_time - previous_time_ble > Tinterval_ble_microsecond)
  {
    receive_ble_Data();
    send_ble_Data(); // send the BLE data
    previous_time_ble = current_time;
    // Serial.print(imu.LKx);
    // Serial.print(" ");
    // Serial.println(imu.RKx);
  }

}

void Compute_Cur_Commands()
{
    if (assist_mode == 1) //walking
    {
      mode = "Walking";
      Cur_command_L =  imu.DOTC[0]/2.2; //this is for bilateral walking assistance_left leg
      Cur_command_R =  imu.DOTC[1]/2.2; //this is for bilateral walking assistance_right leg
    }
    else if (assist_mode == 2) //squatting
    {
      mode = "Squatting";
      Cur_command_L =  0.025 * imu.Gain_E * imu.SquatTorque/2.2;  //this is for bilateral squatting_left leg //  assistance = [0%,50%] body weight when Gain_E = [0,20]
      Cur_command_R = -0.025 * imu.Gain_E * imu.SquatTorque/2.2;  //this is for bilateral squatting_right leg // assistance = [0%,50%] body weight when Gain_E = [0,20]
//      Cur_command_L = min(0, Cur_command_L);
//      Cur_command_R = max(0, Cur_command_R);
    }
    else if (assist_mode == 3) //sine wave
    {
      mode = "Sine wave";
      Cur_command_L =  imu.Gain_E * sin(2 * PI * current_time / (10^6))/2.2;    //(unit Amp);
      Cur_command_R = -imu.Gain_F * sin(2 * PI * current_time / (10^6))/2.2;    //(unit Amp);
    }
    else if (assist_mode == 4)
    {
      mode = "Constant signal";
      //Cur_command_L = 0;
      //Cur_command_R = 0;
    }
    else if (assist_mode == 5)
    {
      mode = "High Level control";
      
      send_serial_Data_Highlevel(); //Serial communication with High level system
      receive_serial_Data_Highlevel();
      Cur_command_L=Left_Knee_Torque_Commend/2.2;
      Cur_command_R=Right_Knee_Torque_Commend/2.2;
    }
    else if (assist_mode == 6)
    {
      mode = "Demo 1";
      //Cur_command_L = 0;
      //Cur_command_R = 0;
    }
    else if (assist_mode == 7)
    {
      mode = "Demo 2";
      //Cur_command_L = 0;
      //Cur_command_R = 0;
    }
    else if (assist_mode == 8)
    {
      mode = "Pediatric Walking IMU Current";
      //Cur_command_L = 0;
      //Cur_command_R = 0;
    }
    else if (assist_mode == 9)
    {
      mode = "Pediatric Walking IMU Torque";
      //Cur_command_L = 0;
      //Cur_command_R = 0;
    }
    else if (assist_mode == 10)
    {
      mode = "Pediatric Walking Insole Current";
      //Cur_command_L = 0;
      //Cur_command_R = 0;
    }
    else if (assist_mode == 11)
    {
      mode = "Pediatric Walking Insole Torque";
      //Cur_command_L = 0;
      //Cur_command_R = 0;
    }
}

void Cur_limitation()
{
//************* Current limitation *************//
    Cur_command_L = min( current_limitation, Cur_command_L);
    Cur_command_L = max(-current_limitation, Cur_command_L);
    Cur_command_R = min( current_limitation, Cur_command_R);
    Cur_command_R = max(-current_limitation, Cur_command_R);
}


void receive_ble_Data()
{
  if (Serial4.available() >= 20)
  {
    Serial.println("-------------New data received-------------------");
    data_rs232_rx[0] = Serial4.read();
    if (data_rs232_rx[0] == 165)
    {
      data_rs232_rx[1] = Serial4.read();
      if (data_rs232_rx[1] == 90)
      {
        Serial4.readBytes(&data_rs232_rx[2], 18);
        if (data_rs232_rx[3] == 0)
        {
          Stop_button = int(data_rs232_rx[4]);
          if (Stop_button)
          {
          Serial.println("STOP button pressed");
          }
          else
          {
          Serial.println("START button pressed");
          }
        }
        else if (data_rs232_rx[3] == 1)
        {
          assist_mode = int(data_rs232_rx[4]);
          Serial.print("Mode: ");
          Serial.println(mode);
        }
        else if (data_rs232_rx[3] == 2)
        {
          imu.Gain_E = ((int16_t)(((uint16_t)data_rs232_rx[4]) | ((uint16_t)data_rs232_rx[5] << 8))) / 1000.0;
          Serial.print("Extension gain: ");
          Serial.println(imu.Gain_E);
        }
        else if (data_rs232_rx[3] == 3)
        {
          imu.Gain_F = ((int16_t)(((uint16_t)data_rs232_rx[4]) | ((uint16_t)data_rs232_rx[5] << 8))) / 1000.0;
          Serial.print("Flexion gain: ");
          Serial.println(imu.Gain_F);
        }
        else if (data_rs232_rx[3] == 4)
        { // 5 ms per timepoint, delaypoint needs to be less than 200
        // 1 delaypoint in matlab interface equals 20 timepoints here, that is 100 ms
          imu.delaypoint = ((int16_t)(((uint16_t)data_rs232_rx[4]) | ((uint16_t)data_rs232_rx[5] << 8))) / 1000 * 20;
          Serial.print("Delay [ms]: ");
          Serial.println(imu.delaypoint*5);
          // delay = delaypoint*sample time
        }
        else if (data_rs232_rx[3] == 5)
        {
          weight = ((int16_t)(((uint16_t)data_rs232_rx[4]) | ((uint16_t)data_rs232_rx[5] << 8))) / 1000.0;
          Serial.print("Weight [kg]: ");
          Serial.println(weight);
        }
      }
    }
  }
}

void send_ble_Data()
{
  LK_ble = imu.LKx * 100;
  RK_ble = imu.RKx * 100;
  current_command_L_ble = Cur_command_L * 100;
  current_command_R_ble = Cur_command_R * 100;
  torque_command_L_ble = imu.DOTC[0] * 100;      //left
  torque_command_R_ble = imu.DOTC[1] * 100;      //right
  torque_L_ble = 0;//torque_sensor1.torque[0] * 100;
  torque_R_ble = 0;//torque_sensor1.torque[1] * 100;


////*** Totally, we send 32byte data
  // 0    header 165      
  // 1    header 90             
  // 2    bluetooth data length
  // ...   
   
  data_ble[0] = 165;
  data_ble[1] = 90;
  data_ble[2] = datalength_ble;
  data_ble[3] = LK_ble;
  data_ble[4] = LK_ble >> 8;
  data_ble[5] = RK_ble;
  data_ble[6] = RK_ble >> 8;
  data_ble[7] = current_command_L_ble;
  data_ble[8] = current_command_L_ble >> 8;
  data_ble[9] = current_command_R_ble;
  data_ble[10] = current_command_R_ble >> 8;
  data_ble[11] = torque_command_L_ble;
  data_ble[12] = torque_command_L_ble >> 8;
  data_ble[13] = torque_command_R_ble;
  data_ble[14] = torque_command_R_ble >> 8;
  data_ble[15] = torque_L_ble;
  data_ble[16] = torque_L_ble >> 8;
  data_ble[17] = torque_R_ble;
  data_ble[18] = torque_R_ble >> 8;

//  data_ble[29] = torque_commandGP_ble;
//  data_ble[30] = torque_commandGP_ble>>8;
//  data_ble[31] = imu.isStand;
//  data_ble[3] = LK_ble;
//  data_ble[4] = LK_ble >> 8;
//  data_ble[5] = RK_ble;
//  data_ble[6] = RK_ble >> 8;
//  data_ble[7] = current_command_L_ble;
//  data_ble[8] = current_command_L_ble >> 8;
//  data_ble[9] = current_command_R_ble;
//  data_ble[10] = current_command_R_ble >> 8;
//  data_ble[11] = torque_command_L_ble;
//  data_ble[12] = torque_command_L_ble >> 8;
//  data_ble[13] = torque_command_R_ble;
//  data_ble[14] = torque_command_R_ble >> 8;
//  data_ble[15] = torque_L_ble;
//  data_ble[16] = torque_L_ble >> 8;
//  data_ble[17] = torque_R_ble;
//  data_ble[18] = torque_R_ble >> 8;
//  data_ble[19] = gait_percent_L_ble;
//  data_ble[20] = gait_percent_L_ble >> 8;
//  data_ble[21] = gait_percent_R_ble;
//  data_ble[22] = gait_percent_R_ble >> 8;
//  data_ble[23] = torque_command_L_ble_insole;
//  data_ble[24] = torque_command_L_ble_insole >> 8;
//  data_ble[25] = torque_command_R_ble_insole;
//  data_ble[26] = torque_command_R_ble_insole >> 8;  
  //Serial.println("in");
  Serial4.write(data_ble, datalength_ble);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////



//void plot_insole_data()
//{
//    Serial.print(insole.normalized_torque_command_L*80);
//    Serial.print("  ");
//    Serial.print(insole.normalized_torque_command_R*80);
//    Serial.print("  ");
//    Serial.print(insole.gait_percent_L);
//    Serial.print("  ");
//    Serial.println(insole.gait_percent_R);
//}

//void plot_torque_sensor_data()
//{
//*** torque_sensor1.torque[0] is the first channel ADC value, [1] is the second ADC value. it can be righ leg or left leg torque sensor, it depends on the connection. 
//*** Here we conncet torque_sensor1.torque[0] to right leg. (the definition is different form the IMU and control (1: righ leg 0:left leg))
//    Serial.print(torque_sensor1.torque[1]);        // plot actual torque from ADC channel 0
//    Serial.println("  ");                          
//    Serial.println(torque_sensor1.torque[1]);      // plot actual torque from ADC channel 1
//}

//void plot_imu_data()
//{
//    Serial.print(imu.LTx); //plot left thigh angle (deg)
//    Serial.print("  ");
//    Serial.print(imu.RTx); //plot righ thigh angle (deg)
//    Serial.print("  ");
//    Serial.print(imu.LSx); //plot left shank angle (deg)
//    Serial.print("  ");
//    Serial.println(imu.RSx); //plot left shank angle (deg)
//    Serial.print("  ");
//    Serial.print(imu.LKx); //plot left knee angle (deg)
//    Serial.print("  ");
//    Serial.println(3imu.RKx); //plot right knee angle (deg)
//}

//void plot_controler_data()
//{
//    Serial.print(m1.cur_A * 10); //plot actual current
//    Serial.print("  ");
//    Serial.print(Cur_command*10); //plot current_command(A)*10
//    Serial.print("  ");
//    Serial.print(imu.LRKx[imu.currentpoint]); //plot current angle difference (left knee angle - righ knee angle)
//    Serial.print("  ");
//    Serial.print(imu.percentage_r/10); //plot right leg gait percentage/10 (0% is heel strike)
//    Serial.print("  ");
//    Serial.print(imu.DOTC[1] * 10); //plot right leg torque command *10 of delay output feedback control
//    Serial.print("  ");
//    Serial.print(0.4*imu.filtered_torque_command[1][0]/0.6);  //plot righ leg filter torque command [1][0]: right leg filter torque command [0][0]: left leg filter torque command
//    Serial.print("  ");
//    Serial.println(0.4*imu.torque_command[1]/0.6);  //plot righ leg torque command [1]: right leg torque command [0]: left leg torque command
//}

//void TorqueControlExample()
//{
//  //  ////******Torque Control Example**********////////
//  current_time = micros();    //query current time (microsencond)
//  //********* use to control the control rate. it is 200Hz currently.(you can control it by "Fsample" variable)**********//
//  if (current_time - previous_time > Tinterval_microsecond) // check if the time period of control loop is already larger than Sample period of control loop (Tinterval_microsecond)
//  {
//    previous_time = current_time; //reset prvious control loop time
//    milli_time_current_double = millis();
//    milli_time_current_double=milli_time_current_double/1000;
//    //Tor_command = 1;  //assign a 0.25Hz sin wave torque with amplitude 1.2 Nm
//    Tor_command = 1 * sin(1 * PI * milli_time_current_double);  //assign a 0.25Hz sin wave torque with amplitude 1.2 Nm
//    Cur_command_1 =(Tor_control.Torque_PID_update(Tor_command, torque_sensor1.torque[0])); // Update the torque PID control and output the PID value as Current command; Torque constant 2*0.069 *36 Nm/A
//    m1.set_current_A_command(Cur_command_1);                       //send current command
//    m1.cur_req();                                               //request current
//    m1.check_data();                                            //check if receive any data
//    torque_sensor1.Torque_sensor_read();                        //read the torque sensor
//
//    //plot howard controller data
////    Serial.print(Cur_command_1 * 10 * 0.35 * 2); //plot current_command(A)*10
////    Serial.print("  ");  // used for serial plotter to seperate the variables
////    Serial.print(m1.cur_A * 10 * 0.35 * 2); //plot actual current
////    Serial.print("  ");  // used for serial plotter to seperate the variables
////    Serial.print(Tor_command * 10); //plot righ leg torque command [1]: right leg torque command [0]: left leg torque command
////    Serial.print("  "); // used for serial plotter to seperate the variables
////    Serial.println(torque_sensor1.torque[0] * 10); //plot righ leg filter torque command [1][0]: right leg filter torque command [0][0]: left leg filter torque command
//
//  }
//}
//
//void CurrentControlExample()
//{
//  //  ////******Current Control Example**********////////
//  //  current_time = millis();
//  //  Cur_command = 1.2 * sin(0.5 * 3.1415 * current_time / 1000);
//  //  m1.set_current_A_command(Cur_command);
//  //  m1.cur_req();
//  //  m1.check_data();
//  //  torque_sensor1.Torque_sensor_read();
//  //  Serial.print(torque_sensor1.torque[1]);//plot torque
//  //  Serial.print("  ");
//  //  Serial.print(Cur_command);//plot current command
//  //  Serial.print("  ");
//  //  Serial.println(m1.cur_A); //plot actual current
//  //  delay(Tsample * 1000);  //unit ms
//  //  ////////////////////////////////////////////////
//}
//
//void PositionControlExample()
//{
//  //*******Position control example*********//////////
//  current_time = millis();
//  Pos_command = 0.15 * sin(0.5 * 3.1415 * current_time / 1000); //assign a 0.25Hz sin wave position with amplitude 0.15 revolution
//  m1.set_relative_revolution_command(Pos_command);              //send position command
//  m1.pos_req();                                                 //request position
//  m1.check_data();                                              //check if receive any data
//  torque_sensor1.Torque_sensor_read();                          //read the torque sensor
//  Serial.print(torque_sensor1.torque[1]);                       //plot torque sensor
//  Serial.print("  ");                                           // used for serial plotter to seperate the variables
//  Serial.print(Pos_command);                                    //plot position command
//  Serial.print("  ");                                           // used for serial plotter to seperate the variables
//  Serial.println(m1.pos_deg_relative / 360);                    //plot actual relative position
//  delay(Tsample * 1000);                                        //unit ms  //use to control the control rate it is 150hz
//  //********************************************************
//}
//
//void TorqueControlSetup()
//{
//  m1.mode = current_control_mode;
//  m1.init_motor_CAN();
//  Tor_control.setPIDgain(Pgain, Igain, Dgain);
//  Tor_control.setMaximunPIDout(MaxPIDout);
//  Tor_control.setSampleFrequency(Fsample);
//  //////////////////////////////////////////
//}
//
//void CurrentControlSetup()
//{
//  ////*****Current Control Setup*********//
//  m1.mode = current_control_mode;
//  m1.init_motor_CAN();
//}
//
//void PositionControlSetup()
//{
//  /////profile_position_control_mode; position_control_mode; velocity_control_mode; current_control_mode
//  //////*****Position Control Setup*********//
//  m1.mode = profile_position_control_mode;
//  m1.init_motor_CAN();
//}

//******************Receive high level controller commend****************//
void receive_serial_Data_Highlevel()
{
  if (Serial.available() >= 7)
  {
    //Serial.println("receive");
    data_highlevel_rx[0] = Serial.read();
    if (data_highlevel_rx[0] == 165)
    {
      data_highlevel_rx[1] = Serial.read();
      if (data_highlevel_rx[1] == 90)
      {
        Serial.readBytes(&data_highlevel_rx[2], 5);//int data_rs232_rx[7]
        //Highlevel_Data_Length_Receive = int(data_highlevel_rx[2]); // read data length
        Left_Knee_Torque_Commend = ((int16_t)(((int16_t)data_highlevel_rx[3]) | ((int16_t)data_highlevel_rx[4] << 8)));
        Right_Knee_Torque_Commend = ((int16_t)(((int16_t)data_highlevel_rx[5]) | ((int16_t)data_highlevel_rx[6] << 8)));
        Left_Knee_Torque_Commend=Left_Knee_Torque_Commend/100;
        Right_Knee_Torque_Commend=Right_Knee_Torque_Commend/100;
       }
      }
    }
}
//******************Send high level controller commend****************//
void send_serial_Data_Highlevel()
{
  LK_highlevel = imu.LKx *100;
  RK_highlevel = imu.RKx *100;

  TK_highlevel = imu.TKx *100;
  LT_highlevel = imu.LTx *100;
  RT_highlevel = imu.RTx *100;
  LS_highlevel = imu.LSx *100;
  RS_highlevel = imu.RSx *100;
  Left_Knee_Torque = Cur_command_L*2.2 *100;
  Right_Knee_Torque = Cur_command_R*2.2 *100;

  data_serial_highlevel[0] = 165;
  data_serial_highlevel[1] = 90;
  data_serial_highlevel[2] = Highlevel_Data_Length_Send;
  data_serial_highlevel[3] = Left_Knee_Torque >> 8;
  data_serial_highlevel[4] = Left_Knee_Torque;
  data_serial_highlevel[5] = Right_Knee_Torque >> 8;
  data_serial_highlevel[6] = Right_Knee_Torque;
  data_serial_highlevel[7] = LK_highlevel >> 8;
  data_serial_highlevel[8] = LK_highlevel;
  data_serial_highlevel[9] = RK_highlevel >> 8;
  data_serial_highlevel[10] = RK_highlevel;
  
  data_serial_highlevel[11] = LT_highlevel >> 8;
  data_serial_highlevel[12] = LT_highlevel;
  data_serial_highlevel[29] = RT_highlevel >> 8;
  data_serial_highlevel[30] = RT_highlevel;
  data_serial_highlevel[47] = LS_highlevel >> 8;
  data_serial_highlevel[48] = LS_highlevel;
  data_serial_highlevel[65] = RS_highlevel >> 8;
  data_serial_highlevel[66] = RS_highlevel;
  data_serial_highlevel[83] = TK_highlevel >> 8;
  data_serial_highlevel[84] = TK_highlevel;
  
//  Serial.print(LT_highlevel); 
//  Serial.print("  "); 
//  Serial.print(RT_highlevel); 
//  Serial.print("  "); 
//  Serial.print(LS_highlevel); 
//  Serial.print("  "); 
//  Serial.print(RS_highlevel); 
//  Serial.print("  "); 
//  Serial.println(TK_highlevel); 

  Serial.write(data_serial_highlevel, Highlevel_Data_Length_Send);
}
